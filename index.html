<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Enhanced Tower Defense</title>
  <style>
    /* ==== BASIC LAYOUT ==== */
    body {
      background: linear-gradient(#1e293b, #000);
      color: #fff;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
      user-select: none;
    }
    #ui {
      padding: 16px;
      background: #111b22ee;
      box-shadow: 0 2px 8px #000a;
      z-index: 2;
      position: relative;
    }
    #hud {
      position: absolute;
      top: 12px;
      left: 12px;
      display: flex;
      gap: 16px;
      background: #0008;
      padding: 8px 12px;
      border-radius: 8px;
      box-shadow: 0 0 8px #0008;
      font-size: 18px;
    }
    #gameCanvas {
      background: #333;
      display: block;
      margin: 24px auto;
      border: 3px solid #222;
      border-radius: 16px;
      box-shadow: 0 0 16px #0008;
      cursor: pointer;
    }
    button {
      padding: 8px 18px;
      margin: 8px 4px;
      border-radius: 8px;
      border: none;
      font-size: 16px;
      background: #2a9d8f;
      color: #fff;
      cursor: pointer;
      transition: 0.1s;
    }
    #startBtn {
      font-size: 18px;
      padding: 10px 24px;
      box-shadow: 0 0 8px #0008;
    }
    button:hover {
      background: #21867a;
    }
    button.selected {
      background: #f4a261;
      box-shadow: 0 0 8px #f4a261;
    }
    .tower-select {
        border: 2px solid #fff5;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="hud">
      <div>Wave <span id="wave">1</span></div>
      <div>üí∞ <span id="money">150</span></div>
      <div>‚ù§Ô∏è <span id="hp">20</span></div>
    </div>
    <button onclick="startWave()" id="startBtn">Start Wave</button>
    <div style="display: inline-block; margin-left: 24px;">
        <button onclick="selectTower('GUN')" id="selectGunTower" class="tower-select selected">Gun Tower ($40)</button>
        <button onclick="selectTower('CANNON')" id="selectCannonTower" class="tower-select">Cannon ($75)</button>
        <button onclick="selectTower('SLOW')" id="selectSlowTower" class="tower-select">Slow Tower ($60)</button>
    </div>
    <span id="gameStatus"></span>
  </div>

  <canvas id="gameCanvas" width="480" height="480"></canvas>

  <script>
    // ==== CONSTANTS (MAP, GRID, GAME CONFIG) ====
    const GRID_SIZE = 8;
    const CELL_SIZE = 60;
    const START_MONEY = 150;
    const START_HP = 20;

    // --- TOWER CONFIG ---
    const TOWER_SPECS = {
        GUN: { cost: 40, range: 100, damage: 1, fireRate: 25, projectileSpeed: 7, color: "#2a9d8f" },
        CANNON: { cost: 75, range: 120, damage: 3, fireRate: 80, projectileSpeed: 5, color: "#e76f51", splashRange: 40 },
        SLOW: { cost: 60, range: 90, slowFactor: 0.5, fireRate: 10, projectileSpeed: 8, color: "#3a86ff" }
    };

    // --- ENEMY CONFIG ---
    const ENEMY_SPECS = {
        NORMAL: { hp: 3, speed: 1.2, reward: 5, color: "#ff4343" },
        TANK: { hp: 12, speed: 0.8, reward: 10, color: "#8338ec" }
    };
    
    // --- WAVE CONFIG ---
    const WAVES = [
        { normal: 10, tank: 0, delay: 40 },
        { normal: 15, tank: 2, delay: 35 },
        { normal: 10, tank: 8, delay: 35 },
        { normal: 25, tank: 5, delay: 30 },
        { normal: 15, tank: 15, delay: 30 },
        { normal: 0, tank: 25, delay: 25 },
    ];

    // ==== GAME STATE ====
    let money, hp, waveNumber, frameCount;
    let towers, enemies, projectiles;
    let gameOver, waveActive;
    let selectedTower = 'GUN';
    let mouse = { x: 0, y: 0 };

    // ==== MAP LAYOUT (1 = path, 0 = empty/buildable) ====
    const map = [
      [1,1,1,1,1,1,1,1],
      [0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,1],
      [1,1,1,1,1,1,1,1]
    ];
    let path = [];

    // ==== PATH CALCULATION ====
    function calcPath() {
      let result = [];
      for (let x = 0; x < GRID_SIZE; x++) result.push({ x, y: 0 });
      for (let y = 1; y < GRID_SIZE; y++) result.push({ x: GRID_SIZE - 1, y });
      for (let x = GRID_SIZE - 2; x >= 0; x--) result.push({ x, y: GRID_SIZE - 1 });
      return result;
    }

    // ==== CANVAS SETUP ====
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // ==== GAME INIT ====
    function resetGame() {
      money = START_MONEY;
      hp = START_HP;
      waveNumber = 1;
      frameCount = 0;
      towers = [];
      enemies = [];
      projectiles = [];
      gameOver = false;
      waveActive = false;
      waveEnemies = [];
      path = calcPath();
      selectTower('GUN');
      document.getElementById("gameStatus").textContent = "Place your towers, then start the wave!";
      updateUI();
    }

    // ==== MAIN GAME LOOP ====
    function gameLoop() {
      if (gameOver) return;
      frameCount++;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid();
      if (waveActive) handleEnemies();
      handleTowers();
      handleProjectiles();
      drawTowers();
      drawEnemies();
      drawProjectiles();
      drawPlacementPreview();
      requestAnimationFrame(gameLoop);
    }

    // ==== ENEMY SPAWNING & MOVEMENT ====
    let waveEnemiesToSpawn = [];
    let waveSpawnDelayCounter = 0;

    function startWave() {
      if (waveActive || gameOver || waveNumber > WAVES.length) return;
      waveActive = true;
      waveEnemiesToSpawn = [];
      const waveData = WAVES[waveNumber - 1];
      for(let i=0; i < waveData.normal; i++) waveEnemiesToSpawn.push('NORMAL');
      for(let i=0; i < waveData.tank; i++) waveEnemiesToSpawn.push('TANK');
      waveEnemiesToSpawn.sort(() => Math.random() - 0.5); // Shuffle enemies
      
      waveSpawnDelayCounter = 0;
      document.getElementById("gameStatus").textContent = `Wave ${waveNumber} in progress!`;
    }

    function handleEnemies() {
      // Spawn enemies
      if (waveEnemiesToSpawn.length > 0 && waveSpawnDelayCounter-- <= 0) {
        const enemyType = waveEnemiesToSpawn.shift();
        const spec = ENEMY_SPECS[enemyType];
        enemies.push({
          type: enemyType,
          pathIndex: 0,
          x: path[0].x * CELL_SIZE + CELL_SIZE / 2,
          y: path[0].y * CELL_SIZE + CELL_SIZE / 2,
          hp: spec.hp,
          maxHp: spec.hp,
          speed: spec.speed,
          originalSpeed: spec.speed,
          reward: spec.reward,
          slowTimer: 0
        });
        waveSpawnDelayCounter = WAVES[waveNumber - 1].delay;
      }

      // Move enemies
      enemies.forEach((e) => {
        // Handle slow effect
        if(e.slowTimer > 0) {
            e.speed = e.originalSpeed * TOWER_SPECS.SLOW.slowFactor;
            e.slowTimer--;
        } else {
            e.speed = e.originalSpeed;
        }

        if (e.pathIndex < path.length - 1) {
          let next = path[e.pathIndex + 1];
          let nx = next.x * CELL_SIZE + CELL_SIZE / 2;
          let ny = next.y * CELL_SIZE + CELL_SIZE / 2;
          let dx = nx - e.x, dy = ny - e.y;
          let dist = Math.hypot(dx, dy);
          if (dist < e.speed) {
            e.x = nx; e.y = ny; e.pathIndex++;
          } else {
            e.x += (dx / dist) * e.speed; e.y += (dy / dist) * e.speed;
          }
        } else {
          hp--;
          e.hp = 0; // Mark for removal
          updateUI();
          if (hp <= 0) endGame(false);
        }
      });
      
      // Remove dead/reached enemies
      let remainingEnemies = [];
      for(const e of enemies) {
          if (e.hp > 0) {
              remainingEnemies.push(e);
          } else {
              if (e.hp <=0 && e.pathIndex < path.length -1) { // Died before reaching end
                money += e.reward;
              }
          }
      }
      enemies = remainingEnemies;

      // Wave finished?
      if (waveEnemiesToSpawn.length === 0 && enemies.length === 0) {
        waveActive = false;
        waveNumber++;
        if(waveNumber > WAVES.length) {
            endGame(true);
            return;
        }
        document.getElementById("gameStatus").textContent = `Wave cleared! Prepare for wave ${waveNumber}.`;
        updateUI();
      }
    }

    // ==== TOWER & PROJECTILE LOGIC ====
    function handleTowers() {
        towers.forEach(t => {
            t.cooldown = Math.max(0, t.cooldown - 1);
            if(t.cooldown > 0) return;

            let target = findTarget(t);
            if(target) {
                t.cooldown = TOWER_SPECS[t.type].fireRate;
                projectiles.push({
                    x: t.x * CELL_SIZE + CELL_SIZE / 2,
                    y: t.y * CELL_SIZE + CELL_SIZE / 2,
                    target: target,
                    type: t.type
                });
            }
        });
    }

    function handleProjectiles() {
        projectiles.forEach((p, index) => {
            if(!p.target || p.target.hp <= 0) {
                projectiles.splice(index, 1);
                return;
            }

            let spec = TOWER_SPECS[p.type];
            let dx = p.target.x - p.x;
            let dy = p.target.y - p.y;
            let dist = Math.hypot(dx, dy);

            if(dist < spec.projectileSpeed) {
                // Hit target
                if (p.type === 'CANNON') {
                    // Splash damage
                    enemies.forEach(e => {
                        if(Math.hypot(e.x - p.target.x, e.y - p.target.y) < spec.splashRange) {
                            e.hp -= spec.damage;
                        }
                    });
                } else if (p.type === 'SLOW') {
                    p.target.slowTimer = 30; // Slow for 30 frames
                } else { // 'GUN'
                    p.target.hp -= spec.damage;
                }
                projectiles.splice(index, 1); // remove projectile
            } else {
                p.x += (dx/dist) * spec.projectileSpeed;
                p.y += (dy/dist) * spec.projectileSpeed;
            }
        });
    }
    
    function findTarget(tower) {
        let target = null;
        let maxDist = TOWER_SPECS[tower.type].range;
        for(const e of enemies) {
            const dist = Math.hypot(e.x - (tower.x * CELL_SIZE + 30), e.y - (tower.y * CELL_SIZE + 30));
            if(dist < maxDist) {
                target = e;
                maxDist = dist; // Target the closest enemy in range
            }
        }
        return target;
    }

    // ==== TOWER PLACEMENT ====
    canvas.addEventListener("click", function(evt) {
      if (gameOver) return;
      let rect = canvas.getBoundingClientRect();
      let gx = Math.floor((evt.clientX - rect.left) / CELL_SIZE);
      let gy = Math.floor((evt.clientY - rect.top) / CELL_SIZE);

      const spec = TOWER_SPECS[selectedTower];
      if (canBuild(gx, gy) && money >= spec.cost) {
        towers.push({ x: gx, y: gy, type: selectedTower, cooldown: 0 });
        money -= spec.cost;
        updateUI();
      }
    });

    canvas.addEventListener("mousemove", (evt) => {
        let rect = canvas.getBoundingClientRect();
        mouse.x = evt.clientX - rect.left;
        mouse.y = evt.clientY - rect.top;
    });
    
    function selectTower(type) {
        selectedTower = type;
        document.querySelectorAll('.tower-select').forEach(btn => btn.classList.remove('selected'));
        document.getElementById(`select${type.charAt(0) + type.slice(1).toLowerCase()}Tower`).classList.add('selected');
    }

    function canBuild(gx, gy) {
      if (gx < 0 || gx >= GRID_SIZE || gy < 0 || gy >= GRID_SIZE) return false;
      if (map[gy][gx] === 1) return false; // on path
      for (let t of towers) { if (t.x === gx && t.y === gy) return false; } // tower exists
      return true;
    }
    
    // ==== DRAWING ====
    function drawGrid() {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          ctx.fillStyle = map[y][x] === 1 ? "#555" : "#333";
          ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE-1, CELL_SIZE-1);
        }
      }
    }
    
    function drawTowers() {
        towers.forEach(t => {
            const spec = TOWER_SPECS[t.type];
            let cx = t.x * CELL_SIZE + CELL_SIZE/2;
            let cy = t.y * CELL_SIZE + CELL_SIZE/2;
            ctx.fillStyle = spec.color;
            ctx.beginPath();
            if(t.type === 'CANNON') {
                 ctx.arc(cx, cy, 18, 0, Math.PI * 2);
            } else if (t.type === 'SLOW') {
                ctx.rect(cx - 15, cy - 15, 30, 30);
            } else { // GUN
                ctx.arc(cx, cy, 15, 0, Math.PI * 2);
            }
            ctx.fill();
        });
    }

    function drawEnemies() {
      enemies.forEach((e) => {
        const spec = ENEMY_SPECS[e.type];
        ctx.fillStyle = e.slowTimer > 0 ? "#add8e6" : spec.color; // Lighter color if slowed
        ctx.beginPath();
        let size = e.type === 'TANK' ? 18 : 14;
        ctx.arc(e.x, e.y, size, 0, Math.PI * 2);
        ctx.fill();
        // Health bar
        ctx.fillStyle = "#111";
        ctx.fillRect(e.x - 15, e.y - (size+8), 30, 6);
        ctx.fillStyle = "#4ade80";
        ctx.fillRect(e.x - 15, e.y - (size+8), 30 * (e.hp / e.maxHp), 6);
      });
    }
    
    function drawProjectiles() {
        projectiles.forEach((p) => {
            const spec = TOWER_SPECS[p.type];
            ctx.fillStyle = spec.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.stroke();
      });
    }

    function drawPlacementPreview() {
        let gx = Math.floor(mouse.x / CELL_SIZE);
        let gy = Math.floor(mouse.y / CELL_SIZE);
        if(!canBuild(gx, gy)) return;

        let cx = gx * CELL_SIZE + CELL_SIZE/2;
        let cy = gy * CELL_SIZE + CELL_SIZE/2;
        const spec = TOWER_SPECS[selectedTower];

        // Draw tower ghost
        ctx.fillStyle = spec.color;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        if(selectedTower === 'CANNON') ctx.arc(cx, cy, 18, 0, Math.PI * 2);
        else if (selectedTower === 'SLOW') ctx.rect(cx - 15, cy - 15, 30, 30);
        else ctx.arc(cx, cy, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw range
        ctx.strokeStyle = "#fff";
        ctx.beginPath();
        ctx.arc(cx, cy, spec.range, 0, Math.PI*2);
        ctx.stroke();
        ctx.globalAlpha = 1.0;
    }

    // ==== UI & GAME STATE ====
    function updateUI() {
      document.getElementById("money").textContent = money;
      document.getElementById("hp").textContent = hp;
      document.getElementById("wave").textContent = waveNumber > WAVES.length ? "WIN" : waveNumber;
    }

    function endGame(win) {
      gameOver = true;
      waveActive = false;
      if (win) {
        document.getElementById("gameStatus").textContent = "Congratulations! You Win!";
      } else {
        document.getElementById("gameStatus").textContent = "Game Over!";
      }
      setTimeout(resetGame, 4000);
    }

    // ==== START ====
    resetGame();
    gameLoop();
  </script>
</body>
</html>
