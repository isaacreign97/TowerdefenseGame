<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Simple Tower Defense</title>
  <style>
    /* ==== BASIC LAYOUT ==== */
    body {
      background: linear-gradient(#1e293b, #000);
      color: #fff;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    #ui {
      padding: 16px;
      background: #111b22ee;
      box-shadow: 0 2px 8px #000a;
      z-index: 2;
      position: relative;
    }
    #hud {
      position: absolute;
      top: 12px;
      left: 12px;
      display: flex;
      gap: 16px;
      background: #0008;
      padding: 8px 12px;
      border-radius: 8px;
      box-shadow: 0 0 8px #0008;
      font-size: 18px;
    }
    #gameCanvas {
      background: #333;
      display: block;
      margin: 24px auto;
      border: 3px solid #222;
      border-radius: 16px;
      box-shadow: 0 0 16px #0008;
    }
    button {
      padding: 8px 18px;
      margin: 8px 4px;
      border-radius: 8px;
      border: none;
      font-size: 16px;
      background: #2a9d8f;
      color: #fff;
      cursor: pointer;
      transition: 0.1s;
    }
    #startBtn {
      font-size: 18px;
      padding: 10px 24px;
      box-shadow: 0 0 8px #0008;
    }
    button:hover {
      background: #21867a;
    }
  </style>
</head>
<body>
  <!-- ==== UI & HUD ==== -->
  <div id="ui">
    <div id="hud">
      <div>Wave <span id="wave">1</span></div>
      <div>üí∞ <span id="money">100</span></div>
      <div>‚ù§Ô∏è <span id="hp">10</span></div>
    </div>
    <button onclick="startWave()" id="startBtn">Start Wave</button>
    <span id="gameStatus"></span>
  </div>

  <!-- ==== GAME CANVAS ==== -->
  <canvas id="gameCanvas" width="480" height="480"></canvas>

  <script>
    // ==== CONSTANTS (MAP, GRID, GAME CONFIG) ====
    const GRID_SIZE = 8;         // 8x8 grid
    const CELL_SIZE = 60;        // Each cell is 60x60 pixels
    const START_MONEY = 100;
    const START_HP = 10;
    const TOWER_COST = 40;
    const TOWER_RANGE = 100;
    const TOWER_DAMAGE = 1;
    const TOWER_FIRE_RATE = 25;  // Higher is slower (frames)
    const ENEMY_HP = 3;
    const ENEMY_SPEED = 1.2;     // Pixels per frame
    const ENEMY_REWARD = 15;

    // ==== GAME STATE ====
    let money = START_MONEY;
    let hp = START_HP;
    let towers = [];
    let enemies = [];
    let projectiles = [];
    let path = [];
    let isPlacingTower = false;
    let gameOver = false;
    let waveActive = false;
    let waveNumber = 1;
    let frameCount = 0;

    // ==== MAP LAYOUT (1 = path, 0 = empty/buildable) ====
    // Simple static path from left to right, can be made more complex
    const map = [
      [1,1,1,1,1,1,1,1],
      [0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,1],
      [0,0,0,0,0,0,0,1],
      [1,1,1,1,1,1,1,1]
    ];

    // ==== PATH CALCULATION ====
    function calcPath() {
      // Hard-coded for demo. Usually you'd use pathfinding.
      let result = [];
      for (let x = 0; x < GRID_SIZE; x++) result.push({ x, y: 0 });
      for (let y = 1; y < GRID_SIZE; y++) result.push({ x: GRID_SIZE-1, y });
      for (let x = GRID_SIZE-2; x >= 0; x--) result.push({ x, y: GRID_SIZE-1 });
      return result;
    }
    path = calcPath();

    // ==== CANVAS SETUP ====
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // ==== GAME INIT ====
    function resetGame() {
      money = START_MONEY;
      hp = START_HP;
      towers = [];
      enemies = [];
      projectiles = [];
      gameOver = false;
      waveActive = false;
      waveNumber = 1;
      frameCount = 0;
      document.getElementById("gameStatus").textContent = "";
      updateUI();
      draw();
    }

    // ==== MAIN GAME LOOP ====
    function gameLoop() {
      if (gameOver) return;
      frameCount++;
      // Move and spawn enemies
      if (waveActive) handleEnemies();
      // Towers fire at enemies
      handleTowers();
      // Projectiles update
      handleProjectiles();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // ==== ENEMY SPAWNING & MOVEMENT ====
    let waveSpawnIndex = 0;
    let waveSpawnDelay = 0;
    function startWave() {
      if (waveActive || gameOver) return;
      waveActive = true;
      waveSpawnIndex = 0;
      waveSpawnDelay = 0;
      document.getElementById("gameStatus").textContent = `Wave ${waveNumber} in progress!`;
    }

    function handleEnemies() {
      // Spawn 10 enemies with delay
      if (waveSpawnIndex < 10 && waveSpawnDelay-- <= 0) {
        enemies.push({
          pathIndex: 0,
          x: path[0].x * CELL_SIZE + CELL_SIZE/2,
          y: path[0].y * CELL_SIZE + CELL_SIZE/2,
          hp: ENEMY_HP,
        });
        waveSpawnIndex++;
        waveSpawnDelay = 40;
      }

      // Move enemies
      enemies.forEach((e) => {
        if (e.pathIndex < path.length-1) {
          let next = path[e.pathIndex+1];
          let nx = next.x * CELL_SIZE + CELL_SIZE/2;
          let ny = next.y * CELL_SIZE + CELL_SIZE/2;
          let dx = nx - e.x, dy = ny - e.y;
          let dist = Math.hypot(dx, dy);
          if (dist < ENEMY_SPEED) {
            e.x = nx;
            e.y = ny;
            e.pathIndex++;
          } else {
            e.x += (dx/dist) * ENEMY_SPEED;
            e.y += (dy/dist) * ENEMY_SPEED;
          }
        } else if (!e.reached) {
          e.reached = true;
          hp--;
          updateUI();
          if (hp <= 0) endGame(false);
        }
      });

      // Remove dead/out enemies
      enemies = enemies.filter(e => e.hp > 0 && !e.reached);

      // Wave finished?
      if (waveSpawnIndex === 10 && enemies.length === 0) {
        waveActive = false;
        document.getElementById("gameStatus").textContent = `Wave ${waveNumber} cleared! Click Start Wave for next round.`;
        money += 25;
        waveNumber++;
        updateUI();
      }
    }

    // ==== TOWER PLACEMENT ====
    canvas.addEventListener("click", function(evt) {
      if (gameOver) return;
      let rect = canvas.getBoundingClientRect();
      let mx = evt.clientX - rect.left;
      let my = evt.clientY - rect.top;
      let gx = Math.floor(mx / CELL_SIZE);
      let gy = Math.floor(my / CELL_SIZE);

      if (canBuild(gx, gy)) {
        if (money < TOWER_COST) {
          alert("Not enough money for a tower!");
          return;
        }
        towers.push({
          x: gx,
          y: gy,
          cooldown: 0
        });
        money -= TOWER_COST;
        updateUI();
      }
    });

    function canBuild(gx, gy) {
      // Not on path, not overlapping tower
      if (!inBounds(gx, gy) || map[gy][gx] === 1) return false;
      return !towers.some(t => t.x === gx && t.y === gy);
    }
    function inBounds(x, y) {
      return x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE;
    }

    // ==== TOWER FIRING ====
    function handleTowers() {
      towers.forEach((t) => {
        if (t.cooldown > 0) {
          t.cooldown--;
          return;
        }
        // Find nearest enemy in range
        let tx = t.x * CELL_SIZE + CELL_SIZE/2;
        let ty = t.y * CELL_SIZE + CELL_SIZE/2;
        let target = null, minDist = TOWER_RANGE;
        enemies.forEach((e) => {
          let dist = Math.hypot(e.x - tx, e.y - ty);
          if (dist < minDist) {
            minDist = dist;
            target = e;
          }
        });
        if (target) {
          projectiles.push({
            x: tx,
            y: ty,
            target: target,
            dx: (target.x - tx) / 15,
            dy: (target.y - ty) / 15
          });
          t.cooldown = TOWER_FIRE_RATE;
        }
      });
    }

    // ==== PROJECTILES ====
    function handleProjectiles() {
      projectiles.forEach((p) => {
        p.x += p.dx;
        p.y += p.dy;
        // Check hit
        let dist = Math.hypot(p.x - p.target.x, p.y - p.target.y);
        if (dist < 12 && enemies.includes(p.target)) {
          p.target.hp -= TOWER_DAMAGE;
          if (p.target.hp <= 0) {
            money += ENEMY_REWARD;
            updateUI();
          }
          p.dead = true;
        }
      });
      projectiles = projectiles.filter(p => !p.dead);
    }

    // ==== DRAWING ====
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw grid & path
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          ctx.strokeStyle = "#444";
          ctx.strokeRect(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
          if (map[y][x] === 1) {
            ctx.fillStyle = "#91712e";
            ctx.fillRect(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
          }
        }
      }

      // Draw towers
      towers.forEach((t) => {
        ctx.fillStyle = "#5eead4";
        ctx.beginPath();
        ctx.arc(t.x*CELL_SIZE+CELL_SIZE/2, t.y*CELL_SIZE+CELL_SIZE/2, 18, 0, Math.PI*2);
        ctx.fill();
        // Tower range indicator (debug)
        // ctx.beginPath();
        // ctx.arc(t.x*CELL_SIZE+CELL_SIZE/2, t.y*CELL_SIZE+CELL_SIZE/2, TOWER_RANGE, 0, Math.PI*2);
        // ctx.strokeStyle = "#38bdf8bb";
        // ctx.stroke();
      });

      // Draw enemies
      enemies.forEach((e) => {
        ctx.fillStyle = "#ff4343";
        ctx.beginPath();
        ctx.arc(e.x, e.y, 14, 0, Math.PI*2);
        ctx.fill();
        // Health bar
        ctx.fillStyle = "#111";
        ctx.fillRect(e.x-15, e.y-22, 30, 6);
        ctx.fillStyle = "#4ade80";
        ctx.fillRect(e.x-15, e.y-22, 30 * (e.hp/ENEMY_HP), 6);
      });

      // Draw projectiles
      projectiles.forEach((p) => {
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
        ctx.fill();
      });
    }

    // ==== UI UPDATES ====
    function updateUI() {
      document.getElementById("money").textContent = money;
      document.getElementById("hp").textContent = hp;
      document.getElementById("wave").textContent = waveNumber;
    }

    // ==== GAME OVER ====
    function endGame(win) {
      gameOver = true;
      document.getElementById("gameStatus").textContent = win ? "You win!" : "Game Over!";
      setTimeout(resetGame, 3000); // Auto-restart after 3s
    }

    // ==== START ====
    resetGame();
    gameLoop();
  </script>
</body>
</html>
