<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Tower Defense v3 ‚Äì UI & Graphics Polish</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<!-- Google Font: Roboto Mono -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">

<style>
  /* ==== PAGE & BASE (UI POLISH) ==== */
  html,body{
    margin:0;
    height:100%;
    background:#111;
    color:#eee;
    font-family:'Roboto Mono', monospace;
    display:flex;
    justify-content:center;
    align-items:center;
  }

  #game{
    background:#222;
    border:2px solid #555;
    border-radius:8px;
    cursor:crosshair;
    touch-action:none;
    image-rendering:pixelated;
  }

  /* ==== HUD ENHANCEMENT ==== */
  #hud{
    position:fixed;
    top:10px;
    left:10px;
    background:rgba(0, 0, 0, 0.5);
    padding:8px 12px;
    border-radius:8px;
    border:1px solid #444;
    display:flex;
    gap:16px;
    align-items:center;
    z-index:10;
    font-size:16px;
  }
  #hud span{ min-width:60px; display:inline-block; }

  /* ==== BUTTON IMPROVEMENTS ==== */
  #towerButtons{ display:inline-flex; gap:4px; }

  button {
    padding:4px 10px;
    font-size:14px;
    border-radius:5px;
    border:1px solid #666;
    background:linear-gradient(to bottom, #444, #222);
    color:#eee;
    cursor:pointer;
    transition:all 0.2s ease;
    box-shadow:0 2px 5px rgba(0,0,0,0.2);
    font-family:'Roboto Mono', monospace;
  }
  button:hover:not(:disabled) {
    background:linear-gradient(to bottom, #555, #333);
    border-color:#888;
    transform:translateY(-1px);
    box-shadow:0 3px 7px rgba(0,0,0,0.3);
  }
  button:disabled {
    opacity:0.4;
    cursor:not-allowed;
    transform:none;
    box-shadow:none;
  }

  #towerButtons button.selected{
    outline:2px solid #0ff;
    box-shadow:0 0 8px rgba(0,255,255,0.7);
  }

  /* ==== OVERLAY & TOWER PANEL POLISH ==== */
  #overlay{position:fixed;inset:0;display:none;justify-content:center;align-items:center;background:rgba(0,0,0,.65);flex-direction:column;gap:12px;z-index:20;text-align:center;}
  #overlay h1{margin:0;font-size:32px;}
  #overlay p{margin:0 0 12px 0;font-size:16px;}

  #startScreen{position:fixed;inset:0;display:flex;justify-content:center;align-items:center;background:rgba(0,0,0,0.8);flex-direction:column;gap:12px;z-index:30;}
  #mapButtons button{margin:4px;}

  #hud, #game{display:none;}

  #towerPanel{
    position:fixed;
    bottom:10px;
    left:10px;
    z-index:15;
    background:rgba(0, 0, 0, 0.7);
    padding:12px;
    border:1px solid #555;
    border-radius:8px;
    display:none;
    min-width:160px;
    box-shadow:0 0 15px rgba(0,0,0,0.5);
  }
  #towerPanel h3{margin:0 0 4px 0;font-size:14px;}
  #towerPanel button{width:100%;margin-top:4px;padding:2px 0;font-size:12px;}
  #towerPanelTargeting{margin-top:8px;display:grid;grid-template-columns:1fr 1fr;gap:4px;}
  #towerPanelTargeting button{width:auto;margin-top:0;padding:2px 4px;}
  #towerPanelTargeting button.selected{background:#555;outline:1px solid #fff;}
</style>
</head>
<body>
<canvas id="game" width="640" height="480"></canvas>

<!-- ===== HUD ===== -->
<div id="hud">
  <span id="cash">üí∞ 0</span>
  <span id="lives">‚ù§Ô∏è 0</span>
  <span id="wave">üåä 0</span>
  <span id="best">üèÜ Best 0</span>
  <div id="towerButtons"></div>
  <button id="spawnBtn">Next Wave</button>
  <button id="pauseBtn">Pause</button>
</div>

<!-- ===== Tower action mini‚Äëpanel (shows when selecting a placed tower) ===== -->
<div id="towerPanel">
  <h3 id="towerPanelTitle">Tower</h3>
  <div id="towerPanelStats"></div>
  <div id="towerPanelTargeting"></div>
  <button id="upgradeBtn">Upgrade</button>
  <button id="sellBtn">Sell</button>
</div>

<!-- ===== Overlay for Pause / Game Over ===== -->
<div id="overlay">
  <h1 id="overlayTitle"></h1>
  <p id="overlayMsg"></p>
  <button id="overlayResume">Resume</button>
  <button id="overlayRestart">Restart</button>
</div>

<!-- ===== Start Screen for Map Selection ===== -->
<div id="startScreen">
  <h1>Select a Map</h1>
  <div id="mapButtons"></div>
</div>

<script>
/* =====================================================================
   CONFIG ‚Äì GAME SIZE, GRID, PATH
   ===================================================================== */
const canvas = document.getElementById('game');
const ctx    = canvas.getContext('2d');
const TILE   = 32;

const MAPS = [
  {name:'Classic', path:[ {x:0,y:6*TILE}, {x:14*TILE,y:6*TILE}, {x:14*TILE,y:12*TILE}, {x:19*TILE,y:12*TILE} ]},
  {name:'Serpentine', path:[ {x:0,y:4*TILE}, {x:5*TILE,y:4*TILE}, {x:5*TILE,y:10*TILE}, {x:12*TILE,y:10*TILE}, {x:12*TILE,y:2*TILE}, {x:19*TILE,y:2*TILE} ]}
];

let PATH, PATH_TILES, PATH_TILE_SET;

/* =====================================================================
   DATA TABLES ‚Äì TOWERS & ENEMIES
   ===================================================================== */
const TOWER_TYPES = {
  basic:  {label:'Basic',  cost:50,  range:96,  fireRate:600, dmg:1,  bulletSpeed:220, color:'#0f0', barrel:'#9f9', canTarget:['ground']},
  rapid:  {label:'Rapid',  cost:80,  range:80,  fireRate:220, dmg:1,  bulletSpeed:300, color:'#0ff', barrel:'#aff', canTarget:['ground']},
  long:   {label:'Long',   cost:100, range:160, fireRate:900, dmg:2,  bulletSpeed:260, color:'#6f6', barrel:'#cfc', canTarget:['ground']},
  splash: {label:'Splash', cost:120, range:110, fireRate:1200,dmg:1,  bulletSpeed:200, splash:48, color:'#ff0', barrel:'#ffc', canTarget:['ground']},
  frost:  {label:'Frost',  cost:90,  range:80,  fireRate:1000,dmg:1,  bulletSpeed:180, color:'#4af', barrel:'#aaf', slow:{power:0.5,duration:1500}, canTarget:['ground']},
  amplifier:{label:'Amp',   cost:150, range:80,  color:'#f80', buff:{type:'dmg',power:1.25}, canTarget:['ground']},
  bank:   {label:'Bank',   cost:200, range:0,   color:'#fc0', income:8, incomeRate:4000, canTarget:['ground']},
  missile:{label:'Missile',cost:110, range:140, fireRate:1500,dmg:5,  bulletSpeed:250, color:'#f44', barrel:'#f99', canTarget:['air']}
};
const ENEMY_TYPES = {
  grunt:  {label:'Grunt',  maxHp:10,  speed:40,  reward:5,  color:'#f00'},
  runner: {label:'Runner', maxHp:6,   speed:70,  reward:6,  color:'#fa0'},
  tank:   {label:'Tank',   maxHp:25,  speed:25,  reward:12, color:'#f0f'},
  mini_grunt:{label:'Mini', maxHp:4,  speed:45,  reward:1,  color:'#f88'},
  splitter:{label:'Splitter',maxHp:15, speed:35, reward:10, color:'#c55'},
  wasp:   {label:'Wasp',   maxHp:8,  speed:55,  reward:8,  color:'#ff5', movement:'air'},
  golem:  {label:'Golem',  maxHp:200, speed:20, reward:100,color:'#779', aura:{type:'disable',range:72}}
};
const TARGETING_MODES = ['first', 'last', 'strongest', 'weakest'];

/* =====================================================================
   GAME STATE & UTILS
   ===================================================================== */
const game = { cash: 100, lives: 10, wave: 0, bestWave: 0, bestCash: 0, towers: [], enemies: [], bullets: [], selectedTower: null, placingType: 'basic', placingGhost: {x:0,y:0,valid:false,visible:false}, paused: false, running: true, waveActive: false, lastTimestamp: performance.now(), spawnQueue: [], spawnClock: 0, currentMapIndex: 0 };
(function loadBest(){ const bw = +localStorage.getItem('td_bestWave'); const bc = +localStorage.getItem('td_bestCash'); if(!isNaN(bw)) game.bestWave = bw; if(!isNaN(bc)) game.bestCash = bc; })();
const dist = (ax,ay,bx,by)=>Math.hypot(ax-bx, ay-by);
const clamp=(v,min,max)=>v<min?min:(v>max?max:v);
function buildPathTiles(){ const tiles=[]; for(let i=0;i<PATH.length-1;i++){ const a=PATH[i], b=PATH[i+1]; const dx = Math.sign(b.x-a.x), dy = Math.sign(b.y-a.y); const steps = Math.abs((dx? (b.x-a.x) : (b.y-a.y)) / TILE); for(let s=0;s<=steps;s++){ tiles.push({gx:(a.x/TILE)+dx*s, gy:(a.y/TILE)+dy*s}); } } return tiles; }

function snapToTile(px,py){ const gx = Math.floor(px / TILE); const gy = Math.floor(py / TILE); return {gx, gy, x: gx*TILE + TILE/2, y: gy*TILE + TILE/2}; }
function isTileBuildable(gx,gy){ return !PATH_TILE_SET.has(`${gx},${gy}`); }
function fmt(n){return Math.floor(n);}

/* =====================================================================
   DRAWING FUNCTIONS (NEW & UPDATED)
   ===================================================================== */
// NEW: Draws a background grid
function drawBackground(){
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  for (let x = 0; x < canvas.width; x += TILE) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
  }
  for (let y = 0; y < canvas.height; y += TILE) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
  }
}
// UPDATED: Draws the path with a dark casing for depth
function drawPath(){
  ctx.strokeStyle='#000';
  ctx.lineWidth=TILE*0.75;
  ctx.lineCap='butt';
  ctx.beginPath();
  ctx.moveTo(PATH[0].x+TILE/2, PATH[0].y+TILE/2);
  for(const p of PATH) ctx.lineTo(p.x+TILE/2,p.y+TILE/2);
  ctx.stroke();

  ctx.strokeStyle='#555';
  ctx.lineWidth=TILE/2;
  ctx.beginPath();
  ctx.moveTo(PATH[0].x+TILE/2, PATH[0].y+TILE/2);
  for(const p of PATH) ctx.lineTo(p.x+TILE/2,p.y+TILE/2);
  ctx.stroke();
}

/* =====================================================================
   CLASSES: Tower, Enemy, Bullet
   ===================================================================== */
class Tower{
  constructor(x,y,typeKey){
    this.x=x; this.y=y; this.type=typeKey; this.level=1;
    this.cooldown=0; this.angle=0; this.targetingMode = 'first';
    this.incomeClock=0; this.disabledUntil=0;
  }
  get stats(){
    const base=TOWER_TYPES[this.type];
    const lvl=this.level;
    const scale=(v,p)=>v*(1+p*(lvl-1));
    const s={
      range: scale(base.range||0,0.10),
      fireRate: base.fireRate? base.fireRate*Math.pow(0.95,lvl-1) : 0,
      dmg: base.dmg? Math.round(scale(base.dmg,0.15)) : 0,
      bulletSpeed: base.bulletSpeed? scale(base.bulletSpeed,0.05) : 0,
      splash: base.splash? scale(base.splash,0.10) : 0,
      color: base.color,
      barrel: base.barrel||'#fff',
      canTarget: base.canTarget||['ground']
    };
    if(base.slow) s.slow = base.slow;
    if(base.buff) s.buff = base.buff;
    if(base.income) { s.income = base.income; s.incomeRate = base.incomeRate; }
    for(const amp of game.towers){
      if(amp.type==='amplifier' && amp!==this){
        const def=TOWER_TYPES['amplifier'];
        const r=def.range*(1+0.10*(amp.level-1));
        if(dist(this.x,this.y,amp.x,amp.y)<=r){
          if(def.buff.type==='dmg' && s.dmg){ s.dmg*=def.buff.power; }
        }
      }
    }
    return s;
  }
  update(dt){
    if(performance.now() < this.disabledUntil) return;
    this.cooldown -= dt;
    const s = this.stats;
    if(this.type==='bank'){
      this.incomeClock += dt;
      if(this.incomeClock >= s.incomeRate){
        game.cash += s.income;
        this.incomeClock -= s.incomeRate;
      }
      return;
    }
    if(this.type==='amplifier') return;
    const targets = game.enemies.filter(e => !e.dead && s.canTarget.includes(e.movement) && dist(this.x, this.y, e.x, e.y) <= s.range);
    if (targets.length === 0) return;
    switch (this.targetingMode) {
      case 'last': targets.sort((a, b) => a.distanceTraveled - b.distanceTraveled); break;
      case 'strongest': targets.sort((a, b) => b.hp - a.hp); break;
      case 'weakest': targets.sort((a, b) => a.hp - b.hp); break;
      default: targets.sort((a, b) => b.distanceTraveled - a.distanceTraveled); break;
    }
    const target = targets[0];
    if(target){ this.angle = Math.atan2(target.y-this.y, target.x-this.x); if(this.cooldown <= 0){ spawnBullet(this, target); this.cooldown = s.fireRate; } }
  }
  // UPDATED: Draws tower with a base and outline for depth
  draw(isSelected=false){
    const s=this.stats;
    // Base
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath(); ctx.arc(this.x,this.y,TILE/2+2,0,Math.PI*2); ctx.fill();
    // Body
    ctx.fillStyle = performance.now() < this.disabledUntil ? '#666' : s.color;
    ctx.beginPath(); ctx.arc(this.x,this.y,TILE/2,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.stroke();
    if(this.type==='amplifier'){
      const pulse=(Math.sin(performance.now()/400)+1)/2;
      const aura=s.range*(0.9+0.1*pulse);
      ctx.fillStyle='rgba(255,128,0,0.25)';
      ctx.beginPath(); ctx.arc(this.x,this.y,aura,0,Math.PI*2); ctx.fill();
    }else if(this.type==='bank'){
      ctx.fillStyle='#000';
      ctx.font='16px monospace';
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText('$',this.x,this.y+1);
    }else{
      const bl = TILE/2;
      ctx.strokeStyle=s.barrel; ctx.lineWidth=4;
      ctx.beginPath(); ctx.moveTo(this.x,this.y); ctx.lineTo(this.x+Math.cos(this.angle)*bl, this.y+Math.sin(this.angle)*bl); ctx.stroke();
      ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.stroke();
    }
    // Selection Ring
    if(isSelected){ ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(this.x,this.y,s.range,0,Math.PI*2); ctx.stroke(); }
  }
}

class Enemy{
  constructor(typeKey, hpScale=1){
    const def=ENEMY_TYPES[typeKey];
    this.type=typeKey;
    this.maxHp = Math.round(def.maxHp * hpScale);
    this.hp = this.maxHp;
    this.speed = def.speed;
    this.reward= def.reward;
    this.color = def.color;
    this.movement = def.movement || 'ground';
    this.x=PATH[0].x+TILE/2;
    this.y=PATH[0].y+TILE/2;
    this.pathIndex=0;
    this.dead=false;
    this.distanceTraveled = 0;
    this.slowUntil=0;
    this.speedMultiplier=1;
  }
  takeDamage(dmg){
    this.hp -= dmg;
    if(this.hp<=0){
      this.dead=true;
      game.cash += this.reward;
      if(this.type==='splitter'){
        for(let i=0;i<2;i++){
          const mini=new Enemy('mini_grunt');
          mini.x=this.x+(Math.random()*8-4);
          mini.y=this.y+(Math.random()*8-4);
          mini.pathIndex=this.pathIndex;
          mini.distanceTraveled=this.distanceTraveled;
          game.enemies.push(mini);
        }
      }
    }
  }
  update(dt){
    if(this.dead) return;
    if(this.movement==='air'){
      const end=PATH[PATH.length-1];
      const tx=end.x+TILE/2, ty=end.y+TILE/2;
      const d=dist(this.x,this.y,tx,ty);
      if(performance.now()>this.slowUntil) this.speedMultiplier=1;
      const travel=(this.speed*this.speedMultiplier)*dt/1000;
      this.distanceTraveled += travel;
      if(travel>=d){ this.x=tx; this.y=ty; this.dead=true; game.lives--; }
      else{ this.x+=((tx-this.x)/d)*travel; this.y+=((ty-this.y)/d)*travel; }
      return;
    }
    const next=PATH[this.pathIndex+1]; if(!next){return;}
    const tx=next.x+TILE/2, ty=next.y+TILE/2;
    const d=dist(this.x,this.y,tx,ty);
    if(performance.now()>this.slowUntil) this.speedMultiplier=1;
    const travel=(this.speed*this.speedMultiplier)*dt/1000;
    this.distanceTraveled += travel;
    if(travel>=d){ this.x=tx; this.y=ty; this.pathIndex++; if(!PATH[this.pathIndex+1]){ this.dead=true; game.lives--; } }
    else{ this.x += ((tx-this.x)/d)*travel; this.y += ((ty-this.y)/d)*travel; }
  }
  // UPDATED: Draws enemy with an outline
  draw(){
    if(this.dead) return;
    const r=TILE/3;
    if(this.movement==='air'){
      ctx.fillStyle='rgba(0,0,0,0.4)';
      ctx.beginPath();
      ctx.ellipse(this.x,this.y+r*0.6,r, r*0.4,0,0,Math.PI*2);
      ctx.fill();
    }
    ctx.fillStyle=this.color;
    ctx.beginPath(); ctx.arc(this.x,this.y,r,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.stroke();
    if(this.speedMultiplier<1){
      ctx.fillStyle='rgba(173,216,255,0.4)';
      ctx.beginPath(); ctx.arc(this.x,this.y,r+4,0,Math.PI*2); ctx.fill();
    }
    // HP bar
    ctx.fillStyle='#0f0';
    const w=(this.hp/this.maxHp)*(TILE*2/3);
    ctx.fillRect(this.x-TILE/3,this.y-TILE/2,w,4);
  }
}

class Bullet{
  constructor(x,y,target,speed,dmg,splash,color,slow){
    this.x=x; this.y=y; this.target=target;
    this.speed=speed; this.dmg=dmg;
    this.splash=splash||0; this.color=color||'#ff0';
    this.slow = slow;
    this.dead=false; this.life=4000;
  }
  update(dt){
    if(this.dead) return;
    this.life -= dt;
    if(this.life<=0){ this.dead=true; return; }
    if(!this.target || this.target.dead){ this.dead=true; return; }
    const d = dist(this.x,this.y,this.target.x,this.target.y) || 1;
    const travel = this.speed*dt/1000;
    const dx = (this.target.x - this.x)/d;
    const dy = (this.target.y - this.y)/d;
    this.x += dx*travel;
    this.y += dy*travel;
    if(dist(this.x,this.y,this.target.x,this.target.y) < 6){
      applyDamage(this.target,this.dmg,this.splash,this.x,this.y,this.slow);
      this.dead=true;
    }
  }
  draw(){ if(this.dead) return; ctx.fillStyle=this.color; ctx.fillRect(this.x-2,this.y-2,4,4); }
}

/* =====================================================================
   GAME LOGIC: Damage, Spawners, Waves
   ===================================================================== */
function applyDamage(target,dmg,splash,ix,iy,slow){
  target.takeDamage(dmg);
  if(slow){
    target.speedMultiplier = slow.power;
    target.slowUntil = performance.now() + slow.duration;
  }
  if(splash>0){
    for(const e of game.enemies){
      if(e===target||e.dead) continue;
      if(dist(ix,iy,e.x,e.y)<=splash){ e.takeDamage(dmg); }
    }
  }
}
function spawnBullet(tower,target){
  const s=tower.stats;
  game.bullets.push(new Bullet(tower.x, tower.y, target, s.bulletSpeed, s.dmg, s.splash, s.color, s.slow));
}

function updateAuras(dt){
  const now = performance.now();
  for(const enemy of game.enemies){
    if(enemy.dead) continue;
    const def = ENEMY_TYPES[enemy.type];
    if(def.aura && def.aura.type==='disable'){
      const range = def.aura.range;
      for(const tower of game.towers){
        if(dist(enemy.x,enemy.y,tower.x,tower.y)<=range){
          tower.disabledUntil = Math.max(tower.disabledUntil, now + 200);
        }
      }
    }
  }
}
function buildWave(n){
  const jobs=[]; let t=0;
  const baseCount = 4 + n; // Gradual enemy count
  // Start waves with 4% base HP and grow roughly 50% each level
  // This yields a softer difficulty curve for early waves
  const hpScale = 0.04 * Math.pow(1.5, n - 1);
  if(n>0 && n % 10 === 0){
    jobs.push({time:0,type:'golem',hpScale:hpScale*10});
    return jobs;
  }
  for(let i=0;i<baseCount;i++){ jobs.push({time:t,type:'grunt',hpScale}); t+=600; }
  if(n>=2){ for(let i=0;i<Math.floor(baseCount/3);i++){ jobs.push({time:300+i*900,type:'runner',hpScale:hpScale*0.8}); } }
  if(n>=3){ for(let i=0;i<Math.floor(baseCount/4);i++){ jobs.push({time:150+i*800,type:'wasp',hpScale:hpScale*0.9}); } }
  if(n>=4){ for(let i=0;i<Math.floor(baseCount/4);i++){ jobs.push({time:200+i*800,type:'splitter',hpScale:hpScale*1.2}); } }
  if(n%5===0 && n>0){ for(let i=0;i<Math.ceil(n/5);i++){ jobs.push({time: t + i*1200,type:'tank',hpScale:hpScale*1.5}); } }
  jobs.sort((a,b)=>a.time-b.time);
  return jobs;
}
function startWave(){ if(game.waveActive) return; game.wave++; game.spawnQueue = buildWave(game.wave); game.spawnClock = 0; game.waveActive = true; updateHUD(); spawnBtn.disabled=true; }
function updateSpawner(dt){
  if(!game.waveActive) return;
  game.spawnClock += dt;
  while(game.spawnQueue.length && game.spawnQueue[0].time <= game.spawnClock){ const job=game.spawnQueue.shift(); game.enemies.push(new Enemy(job.type, job.hpScale)); }
  if(!game.spawnQueue.length && !game.enemies.some(e=>!e.dead)){ game.waveActive=false; spawnBtn.disabled=false; }
}

/* =====================================================================
   UI & INPUT HANDLERS
   ===================================================================== */
const cashEl=document.getElementById('cash'), livesEl=document.getElementById('lives'), waveEl=document.getElementById('wave'), bestEl=document.getElementById('best'), spawnBtn=document.getElementById('spawnBtn'), pauseBtn=document.getElementById('pauseBtn'), towerButtonsEl=document.getElementById('towerButtons'), towerPanelEl=document.getElementById('towerPanel'), towerPanelTitle=document.getElementById('towerPanelTitle'), towerPanelStats=document.getElementById('towerPanelStats'), towerPanelTargetingEl=document.getElementById('towerPanelTargeting'), upgradeBtn=document.getElementById('upgradeBtn'), sellBtn=document.getElementById('sellBtn'), overlayEl=document.getElementById('overlay'), overlayTitle=document.getElementById('overlayTitle'), overlayMsg=document.getElementById('overlayMsg'), overlayResume=document.getElementById('overlayResume'), overlayRestart=document.getElementById('overlayRestart'), startScreenEl=document.getElementById('startScreen'), mapButtons=document.getElementById('mapButtons'), hud=document.getElementById('hud');
spawnBtn.addEventListener('click', startWave);
pauseBtn.addEventListener('click', ()=>togglePause(true));
window.addEventListener('keydown',e=>{ if(e.code==='Space' || e.key==='p' || e.key==='P'){ e.preventDefault(); togglePause(true); } });
function togglePause(fromUser){ if(!game.running && fromUser) return; game.paused = !game.paused; pauseBtn.textContent = game.paused? 'Resume':'Pause'; if(game.paused) showOverlay('Paused','Game is paused. Press Resume or P/Space.',true); else hideOverlay(); }
function buildTowerButtons(){ towerButtonsEl.innerHTML=''; Object.entries(TOWER_TYPES).forEach(([key,def])=>{ const btn=document.createElement('button'); btn.textContent=`${def.label} (${def.cost})`; btn.dataset.type=key; btn.style.borderColor=def.color; btn.addEventListener('click',()=>selectPlacingType(key)); towerButtonsEl.appendChild(btn); }); refreshTowerButtonStates(); }
function selectPlacingType(type){ game.placingType=type; refreshTowerButtonStates(); }
function refreshTowerButtonStates(){ [...towerButtonsEl.children].forEach(btn=>{ const type=btn.dataset.type; const def=TOWER_TYPES[type]; const affordable = game.cash>=def.cost; btn.classList.toggle('selected', type===game.placingType); btn.classList.toggle('disabled', !affordable); }); }
canvas.addEventListener('mousemove',e=>{ const rect=canvas.getBoundingClientRect(); const mx=e.clientX-rect.left, my=e.clientY-rect.top; const snap=snapToTile(mx,my); game.placingGhost.x=snap.x; game.placingGhost.y=snap.y; if(game.selectedTower){return;} const buildable=isTileBuildable(snap.gx,snap.gy); const def=TOWER_TYPES[game.placingType]; const affordable=game.cash>=def.cost; game.placingGhost.valid=buildable && affordable; game.placingGhost.visible=true; });
canvas.addEventListener('mouseleave',()=>{game.placingGhost.visible=false;});
canvas.addEventListener('click',e=>{ if(game.paused||!game.running) return; const rect=canvas.getBoundingClientRect(); const mx=e.clientX-rect.left, my=e.clientY-rect.top; const t=findTowerAt(mx,my); if(t){selectTower(t);return;} const snap=snapToTile(mx,my); attemptPlaceTower(snap.gx,snap.gy,snap.x,snap.y); });
function findTowerAt(px,py){ return game.towers.find(t=>dist(px,py,t.x,t.y)<=TILE/2); }
function attemptPlaceTower(gx,gy,x,y){ const def=TOWER_TYPES[game.placingType]; if(game.cash < def.cost || !isTileBuildable(gx,gy)) return; game.towers.push(new Tower(x,y,game.placingType)); game.cash-=def.cost; refreshTowerButtonStates(); updateHUD(); }
function selectTower(tower){ game.selectedTower=tower; showTowerPanel(tower); game.placingGhost.visible=false; }
function deselectTower(){ game.selectedTower=null; towerPanelEl.style.display='none'; game.placingGhost.visible=true; }
function showTowerPanel(t){ const def=TOWER_TYPES[t.type]; const nextLevel=t.level+1; const upgradeCost=Math.round(def.cost*nextLevel*0.75); const sellValue=Math.round(def.cost*t.level*0.5); towerPanelTitle.textContent=`${def.label} L${t.level}`; const s=t.stats; towerPanelStats.innerHTML=`Range: ${fmt(s.range)}<br>Dmg: ${s.dmg}${s.splash?` (splash ${fmt(s.splash)})`:''}<br>Fire: ${fmt(s.fireRate)}ms`; upgradeBtn.textContent=`Upgrade (${upgradeCost})`; upgradeBtn.disabled = game.cash < upgradeCost; sellBtn.textContent=`Sell (+${sellValue})`; towerPanelTargetingEl.innerHTML = ''; TARGETING_MODES.forEach(mode => { const btn = document.createElement('button'); btn.textContent = mode.charAt(0).toUpperCase() + mode.slice(1); btn.dataset.mode = mode; if (t.targetingMode === mode) btn.classList.add('selected'); btn.addEventListener('click', () => { t.targetingMode = mode; showTowerPanel(t); }); towerPanelTargetingEl.appendChild(btn); }); towerPanelEl.style.display='block'; upgradeBtn.onclick=()=>{upgradeTower(t,upgradeCost);}; sellBtn.onclick=()=>{sellTower(t,sellValue);}; }
function upgradeTower(t,cost){ if(game.cash < cost) return; game.cash-=cost; t.level++; refreshTowerButtonStates(); updateHUD(); showTowerPanel(t); }
function sellTower(t,value){ const i=game.towers.indexOf(t); if(i>=0) game.towers.splice(i,1); game.cash+=value; refreshTowerButtonStates(); updateHUD(); deselectTower(); }
window.addEventListener('click',e=>{ if(e.target.closest('#towerPanel')||e.target.closest('canvas')) return; if(game.selectedTower) deselectTower(); });
overlayResume.addEventListener('click',()=>{if(game.running){togglePause(false);}else{hideOverlay();}});
overlayRestart.addEventListener('click',()=>{hideOverlay();showStartScreen();});
function showOverlay(title,msg,showResume){ overlayTitle.textContent=title; overlayMsg.textContent=msg; overlayResume.style.display=showResume?'inline-block':'none'; overlayEl.style.display='flex'; }
function hideOverlay(){overlayEl.style.display='none';}

function showStartScreen(){
  startScreenEl.style.display='flex';
  canvas.style.display='none';
  hud.style.display='none';
  mapButtons.innerHTML='';
  MAPS.forEach((m,i)=>{
    const b=document.createElement('button');
    b.textContent=m.name;
    b.addEventListener('click',()=>initializeGame(i));
    mapButtons.appendChild(b);
  });
}

function initializeGame(idx){
  startScreenEl.style.display='none';
  canvas.style.display='block';
  hud.style.display='flex';
  game.currentMapIndex=idx;
  PATH=MAPS[idx].path;
  PATH_TILES=buildPathTiles();
  PATH_TILE_SET=new Set(PATH_TILES.map(t=>`${t.gx},${t.gy}`));
  resetGame();
  requestAnimationFrame(loop);
}

/* =====================================================================
   GAME LIFECYCLE: Reset, Game Over, Loop
   ===================================================================== */
function resetGame(){
  Object.assign(game, { cash: 100, lives: 10, wave: 0, towers: [], enemies: [], bullets: [], running: true, paused: false, waveActive: false, spawnQueue: [], spawnClock: 0, selectedTower: null, placingType: 'basic', placingGhost: {visible:false} });
  pauseBtn.textContent='Pause';
  spawnBtn.disabled=false;
  refreshTowerButtonStates();
  updateHUD();
  hideOverlay();
}
function onGameOver(){ game.running=false; if(game.wave>game.bestWave){game.bestWave=game.wave;localStorage.setItem('td_bestWave',game.wave);} if(game.cash>game.bestCash){game.bestCash=game.cash;localStorage.setItem('td_bestCash',game.cash);} updateHUD(); showOverlay('Game Over',`You survived wave ${game.wave}!`,false); }
function updateHUD(){ cashEl.textContent = `üí∞ ${fmt(game.cash)}`; livesEl.textContent= `‚ù§Ô∏è ${fmt(game.lives)}`; waveEl.textContent = `üåä ${fmt(game.wave)}`; bestEl.textContent = `üèÜ Best ${fmt(game.bestWave)}/${fmt(game.bestCash)}`; }
function loop(ts){ const dt = clamp(ts - game.lastTimestamp, 0, 50); game.lastTimestamp=ts; if(game.running && !game.paused){ update(dt); } draw(); if(game.running || game.paused){requestAnimationFrame(loop);} }
function update(dt){
  for(const t of game.towers) t.update(dt);
  for(const e of game.enemies) e.update(dt);
  for(const b of game.bullets) b.update(dt);
  updateAuras(dt);
  updateSpawner(dt);
  game.enemies = game.enemies.filter(e=>!e.dead);
  game.bullets = game.bullets.filter(b=>!b.dead);
  if(game.lives<=0 && game.running){onGameOver();}
  updateHUD();
}
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBackground(); // Draw the new background first
  drawPath();
  if(game.placingGhost.visible && !game.selectedTower){ const def=TOWER_TYPES[game.placingType]; const col=game.placingGhost.valid?'rgba(0,255,0,0.25)':'rgba(255,0,0,0.25)'; ctx.fillStyle=col; ctx.beginPath(); ctx.arc(game.placingGhost.x,game.placingGhost.y,TILE/2,0,Math.PI*2); ctx.fill(); ctx.strokeStyle=col; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(game.placingGhost.x,game.placingGhost.y,def.range,0,Math.PI*2); ctx.stroke(); }
  for(const t of game.towers){t.draw(t===game.selectedTower);}
  for(const e of game.enemies){e.draw();}
  for(const b of game.bullets){b.draw();}
}

/* =====================================================================
   INITIALIZE
   ===================================================================== */
buildTowerButtons();
updateHUD();
showStartScreen();

</script>
</body>
</html>
